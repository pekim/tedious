const dataTypeByName = require('../../../src/data-type').typeByName;
const WritableTrackingBuffer = require('../../../src/tracking-buffer/writable-tracking-buffer');
const StreamParser = require('../../../src/token/stream-parser');
const { alwaysEncryptedOptions } = require('../always-encrypted/crypto-util');
const assert = require('chai').assert;

describe('Colmetadata Token Parser', () => {
  describe('parsing the column metadata for a result with many columns', function() {
    it('should parse them correctly', async function() {
      const userType = 2;
      const flags = 3;
      const columnName = 'name';

      const buffer = new WritableTrackingBuffer(50, 'ucs2');

      buffer.writeUInt8(0x81);
      // Column Count
      buffer.writeUInt16LE(1024);

      for (let i = 0; i < 1024; i++) {
        buffer.writeUInt32LE(userType);
        buffer.writeUInt16LE(flags);
        buffer.writeUInt8(dataTypeByName.Int.id);
        buffer.writeBVarchar(columnName);
      }

      const parser = StreamParser.parseTokens([buffer.data], {}, {});

      const result = await parser.next();
      assert.isFalse(result.done);
      const token = result.value;

      assert.isOk(!token.error);

      assert.strictEqual(token.columns.length, 1024);

      for (let i = 0; i < 1024; i++) {
        assert.strictEqual(token.columns[i].userType, 2);
        assert.strictEqual(token.columns[i].flags, 3);
        assert.strictEqual(token.columns[i].type.name, 'Int');
        assert.strictEqual(token.columns[i].colName, 'name');
      }

      assert.isTrue((await parser.next()).done);
    });
  });

  it('should int', async () => {
    const numberOfColumns = 1;
    const userType = 2;
    const flags = 3;
    const columnName = 'name';

    const buffer = new WritableTrackingBuffer(50, 'ucs2');

    buffer.writeUInt8(0x81);
    buffer.writeUInt16LE(numberOfColumns);
    buffer.writeUInt32LE(userType);
    buffer.writeUInt16LE(flags);
    buffer.writeUInt8(dataTypeByName.Int.id);
    buffer.writeBVarchar(columnName);
    // console.log(buffer.data)

    const parser = StreamParser.parseTokens([buffer.data], {}, {});

    const result = await parser.next();
    assert.isFalse(result.done);
    const token = result.value;

    assert.isNotNull(token);
    assert.isOk(!token.error);
    assert.strictEqual(token.columns.length, 1);
    assert.strictEqual(token.columns[0].userType, 2);
    assert.strictEqual(token.columns[0].flags, 3);
    assert.strictEqual(token.columns[0].type.name, 'Int');
    assert.strictEqual(token.columns[0].colName, 'name');

    assert.isTrue((await parser.next()).done);
  });

  it('should varchar', async () => {
    const numberOfColumns = 1;
    const userType = 2;
    const flags = 3;
    const length = 3;
    const collation = Buffer.from([0x09, 0x04, 0x50, 0x78, 0x9a]);
    const columnName = 'name';

    const buffer = new WritableTrackingBuffer(50, 'ucs2');

    buffer.writeUInt8(0x81);
    buffer.writeUInt16LE(numberOfColumns);
    buffer.writeUInt32LE(userType);
    buffer.writeUInt16LE(flags);
    buffer.writeUInt8(dataTypeByName.VarChar.id);
    buffer.writeUInt16LE(length);
    buffer.writeBuffer(collation);
    buffer.writeBVarchar(columnName);
    // console.log(buffer)


    const parser = StreamParser.parseTokens([buffer.data], {}, {});
    const result = await parser.next();
    assert.isFalse(result.done);
    const token = result.value;
    assert.isOk(!token.error);
    assert.strictEqual(token.columns.length, 1);
    assert.strictEqual(token.columns[0].userType, 2);
    assert.strictEqual(token.columns[0].flags, 3);
    assert.strictEqual(token.columns[0].type.name, 'VarChar');
    assert.strictEqual(token.columns[0].collation.lcid, 0x0409);
    assert.strictEqual(token.columns[0].collation.codepage, 'CP1257');
    assert.strictEqual(token.columns[0].collation.flags, 0x85);
    assert.strictEqual(token.columns[0].collation.version, 0x7);
    assert.strictEqual(token.columns[0].collation.sortId, 0x9a);
    assert.strictEqual(token.columns[0].colName, 'name');
    assert.strictEqual(token.columns[0].dataLength, length);
  });

  it('should parse crypto-metadata', async () => {
    const alwaysEncryptedOptionsLocal = { ...alwaysEncryptedOptions };
    const alwaysEncryptedCEK = Buffer.from([
      // decrypted column key must be 32 bytes long for AES256
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);

    alwaysEncryptedOptionsLocal.encryptionKeyStoreProviders = {
      'MSSQL_JAVA_KEYSTORE': {
        decryptColumnEncryptionKey: () => Promise.resolve(alwaysEncryptedCEK),
      },
    };

    const buffer = Buffer.from([
      // -----
      // framing seq ...
      // 0x04, 0x01, 0x02, 0xE7, 0x00, 0x34, 0x01, 0x00,

      0x81,                     // token type         (COLMETADATA)
      0x01, 0x00,               // number of columns  (1)

      // -----
      // CEK table (server must support column encryption)
      0x01, 0x00,               // cek table size     (1)

      // CEK entry 1
      0x05, 0x00, 0x00, 0x00,   // database id        (5)
      0x31, 0x00, 0x00, 0x00,   // key id             (49)
      0x01, 0x00, 0x00, 0x00,   // key version        (1)
      0xF1, 0x08, 0x60, 0x01,   // digest version
      0xE8, 0xAA, 0x00, 0x00,   // (cont.d)
      0x01,                     // cek value count    (1)

      // CEK entry 1, value 1
      0x0D, 0x02,               // encrypted cek len  (525)
      // encrypted cek data ... (525 bytes)
      0x01, 0x08, 0x00, 0x00,
      0x01, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74,
      0x00, 0xA7, 0x31, 0x79, 0xA5, 0x48, 0xEC, 0xA9,
      0x2E, 0x83, 0x66, 0x3D, 0x71, 0x7A, 0x01, 0x43,
      0x3A, 0x26, 0xDE, 0x1D, 0x25, 0xFB, 0x39, 0x26,
      0xE3, 0x58, 0x5C, 0x35, 0x38, 0x4D, 0x99, 0xE1,
      0x23, 0x48, 0xEA, 0x87, 0x61, 0xED, 0x15, 0x6E,
      0x64, 0xF2, 0x78, 0x87, 0xFC, 0x90, 0x5A, 0xFE,
      0x2C, 0x5A, 0x97, 0xDF, 0x79, 0x7C, 0x4F, 0x42,
      0x13, 0xCC, 0xA1, 0xAA, 0x81, 0x76, 0xD1, 0x21,
      0x99, 0xD4, 0xB6, 0x5D, 0x0F, 0x1E, 0xAD, 0x6C,
      0x0B, 0x5E, 0x90, 0xA2, 0xA6, 0xFC, 0x18, 0x07,
      0x77, 0x1D, 0x3A, 0x7D, 0x8A, 0x8B, 0x67, 0xAA,
      0xDD, 0xF6, 0x65, 0xAF, 0xA1, 0x20, 0x14, 0xCC,
      0xB9, 0x95, 0x06, 0xAB, 0x8E, 0xDC, 0x76, 0x56,
      0xAB, 0x55, 0xC5, 0x97, 0xC8, 0x07, 0x7E, 0xA3,
      0xB8, 0x96, 0x45, 0x84, 0x1A, 0xDE, 0x51, 0x7F,
      0xB0, 0x70, 0x12, 0x00, 0x56, 0x0F, 0x97, 0xCB,
      0xB6, 0xFC, 0x9B, 0x14, 0xAF, 0x15, 0x9A, 0x7A,
      0x11, 0x09, 0xA7, 0x7D, 0xDE, 0x46, 0xA4, 0x31,
      0xBD, 0xCF, 0x43, 0x9A, 0xC1, 0x34, 0xC7, 0x2A,
      0xF6, 0x9E, 0xF5, 0xC9, 0xE2, 0xF0, 0x39, 0xCB,
      0xA4, 0xCF, 0x64, 0x4E, 0xB5, 0x49, 0xC1, 0x23,
      0x00, 0xD7, 0x2C, 0x75, 0x1E, 0x6A, 0x00, 0x8E,
      0x2C, 0x0A, 0x57, 0x53, 0x4F, 0xBB, 0x51, 0xE7,
      0xA2, 0x6B, 0x7F, 0xAF, 0xCA, 0x6C, 0x28, 0x5F,
      0x94, 0xD8, 0x0F, 0x44, 0x57, 0xE3, 0xA7, 0x44,
      0x37, 0x3A, 0x7A, 0xB3, 0xB7, 0xBA, 0x33, 0xBF,
      0x90, 0xF9, 0x8C, 0xD2, 0x4E, 0x5B, 0x7F, 0x84,
      0x2E, 0x29, 0x3F, 0xE7, 0x12, 0xBE, 0x01, 0xB7,
      0xC8, 0x04, 0x2D, 0xAE, 0x03, 0x20, 0xFF, 0x2C,
      0xD2, 0x51, 0x4B, 0xD7, 0x72, 0x93, 0x6E, 0x3B,
      0x2D, 0x27, 0xAB, 0xBE, 0x75, 0x36, 0x7F, 0x75,
      0x8B, 0xDD, 0xB6, 0xF6, 0xFB, 0x13, 0x61, 0x90,
      0xDA, 0x0E, 0x35, 0x23, 0x22, 0xBF, 0x49, 0x82,
      0xA7, 0xAB, 0xCB, 0x63, 0xA3, 0x3C, 0xE6, 0xDA,
      0x8B, 0x73, 0x35, 0xD3, 0x3F, 0xB4, 0x6E, 0xA0,
      0x63, 0x32, 0x79, 0x9F, 0x01, 0x85, 0xD7, 0x47,
      0x43, 0xE5, 0xBC, 0x6C, 0x31, 0x8D, 0x7E, 0x7E,
      0x17, 0xC5, 0x61, 0x3F, 0x37, 0x31, 0x41, 0x3D,
      0x41, 0x23, 0x60, 0xA8, 0xE4, 0x1E, 0xBF, 0x2E,
      0xBC, 0x14, 0x12, 0x0D, 0x11, 0xD3, 0xEB, 0x74,
      0x39, 0x95, 0xB3, 0x09, 0x3B, 0x40, 0x6C, 0xD2,
      0x19, 0x53, 0x93, 0xEC, 0x7A, 0x75, 0x94, 0x46,
      0x29, 0x8F, 0x32, 0xF4, 0xFC, 0xE4, 0xB9, 0xF7,
      0xF6, 0x5F, 0x22, 0x5A, 0xD8, 0x33, 0xCA, 0x58,
      0x9D, 0x52, 0xF8, 0x22, 0xFA, 0xB3, 0x18, 0xEE,
      0xDE, 0x83, 0x82, 0xAA, 0x90, 0xC9, 0x29, 0xF9,
      0x4F, 0x17, 0xA1, 0xD6, 0x87, 0x55, 0x3D, 0x1E,
      0xDB, 0xF3, 0xD6, 0xCF, 0x87, 0xB0, 0x5E, 0x57,
      0x35, 0x0C, 0x07, 0x64, 0x96, 0xFD, 0x2E, 0x30,
      0xEF, 0x32, 0x85, 0x6F, 0xE4, 0xF8, 0x5F, 0xA1,
      0x5E, 0x50, 0x04, 0x36, 0x0D, 0xAA, 0x80, 0x18,
      0xC9, 0x0C, 0xCB, 0x21, 0x08, 0xA3, 0x17, 0xCB,
      0xD3, 0x5C, 0xFF, 0x18, 0x4A, 0x5B, 0x9A, 0xB6,
      0x5F, 0x46, 0x43, 0x76, 0x30, 0x0C, 0x6B, 0x94,
      0xF0, 0x2F, 0xFE, 0x5C, 0xF1, 0x57, 0x9E, 0x79,
      0x3B, 0x1A, 0xD0, 0x6C, 0xBE, 0xF4, 0x9D, 0xF5,
      0x40, 0x1C, 0xF4, 0xB3, 0x53, 0x73, 0xCA, 0xEE,
      0xD2, 0xF6, 0xC7, 0xB6, 0xEA, 0x38, 0x7F, 0xDB,
      0x46, 0x06, 0x63, 0x8C, 0xFC, 0x86, 0x1D, 0xF4,
      0xD1, 0xA3, 0xE4, 0x16, 0x9A, 0xEF, 0x31, 0x56,
      0x4D, 0x19, 0xD7, 0xAE, 0x5B, 0x4D, 0x4E, 0xB5,
      0xDD, 0x47, 0x1A, 0x1B, 0x6D, 0x1E, 0x8D, 0x2B,
      0x63, 0x2B, 0xB7, 0x11, 0x35, 0xE5, 0x3C, 0x52,
      0x5A, 0x5A, 0xA6, 0x27, 0x89, 0x09, 0xA6, 0xB6,
      0xF4,

      0x13,                     // keystore name len  (19)
      // keystore name ... (19 x2 bytes)

      0x4D, 0x00,  // 'M'
      0x53, 0x00,  // 'S'
      0x53, 0x00,  // 'S'
      0x51, 0x00,  // 'Q'
      0x4C, 0x00,  // 'L'
      0x5F, 0x00,  // '_'
      0x4A, 0x00,  // 'J'
      0x41, 0x00,  // 'A'
      0x56, 0x00,  // 'V'
      0x41, 0x00,  // 'A'
      0x5F, 0x00,  // '_'
      0x4B, 0x00,  // 'K'
      0x45, 0x00,  // 'E'
      0x59, 0x00,  // 'Y'
      0x53, 0x00,  // 'S'
      0x54, 0x00,  // 'T'
      0x4F, 0x00,  // 'O'
      0x52, 0x00,  // 'R'
      0x45, 0x00,  // 'E'

      0x04,                     // key path length    (4)

      // key path ... (4 x2 bytes)
      0x00, 0x74,  // 't'
      0x00, 0x65,  // 'e'
      0x00, 0x73,  // 's'
      0x00, 0x74,  // 't'

      0x00, 0x08,               // algo name length   (8)

      // algo name ... (8 x2 bytes)
      0x52, 0x00,  // 'R'
      0x53, 0x00,  // 'S'
      0x41, 0x00,  // 'A'
      0x5F, 0x00,  // '_'
      0x4F, 0x00,  // 'O'
      0x41, 0x00,  // 'A'
      0x45, 0x00,  // 'E'
      0x50, 0x00,  // 'P'

      // -----
      // Column 1
      0x00, 0x00, 0x00, 0x00,   // user type          (0)
      0x0B, 0x08,               // flags              (2059)
      0xA5,                     // data type          (BIGVARBIN)

      // varbinary ...
      0x41, 0x02,               // varbinary len      (577)
      // no precision
      // no scale

      // no collation
      // no schema
      // no user-defined type

      // no column-level table data

      // Column 1, crypto metadata
      0x00, 0x00,               // crypto meta ord    (0)
      0x00, 0x00, 0x00, 0x00,   // crypto user type   (0)
      0xA7,                     // crypto data type   (BIGVARCHR)
      // no flags

      // varchar ...
      0x00, 0x02,               // varchar len        (512)
      // no precision
      // no scale

      // collation ...
      0x09, 0x04, 0x00,         // lcid               (1033)
      0x02,                     // flags              (0)
      // version            (2)
      0x00,                     // sortid             (0)
      // => codepage CP1252

      // no schema
      // no user-defined type
      0x02,                     // crypto algo id     (2)
      // no crypto algo name

      0x01,                     // crypto enc type    (1)
      0x01,                     // norm rule vers     (1)

      // Column 1, column info
      0x04,                     // col name len       (4)
      0x4E, 0x00,  // 'N'
      0x61, 0x00,  // 'a'
      0x6D, 0x00,  // 'm'
      0x65, 0x00,  // 'e'

      // -----
      // row data ...
      // 0xD1, 0x41,
      // 0x00, 0x01, 0x89, 0xE1, 0x38, 0xB4, 0xA2, 0x5B,
      // 0x62, 0xE2, 0x5E, 0x49, 0x95, 0xE9, 0x19, 0xDC,
      // 0x46, 0x63, 0xB1, 0x45, 0x86, 0x07, 0x5C, 0x53,
      // 0x9F, 0xB1, 0x54, 0x6E, 0x64, 0x98, 0xBA, 0xD9,
      // 0xF6, 0x48, 0x46, 0x95, 0xB9, 0xD4, 0x3D, 0xF8,
      // 0xE6, 0x55, 0xEA, 0x48, 0xFF, 0xE4, 0xDD, 0x9F,
      // 0xA1, 0x17, 0x70, 0xD5, 0xA1, 0xF8, 0x44, 0x68,
      // 0x8D, 0x62, 0xA3, 0x47, 0x76, 0x0A, 0x4E, 0xCF,
      // 0x19, 0xBD, 0xFD, 0x10, 0x00, 0xC1, 0x00, 0x01,
      // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
    // console.log(buffer);

    const parser = StreamParser.parseTokens([buffer], {}, alwaysEncryptedOptionsLocal);
    const result = await parser.next();

    assert.isFalse(result.done);
    const token = result.value;
    assert.isOk(!token.error);

    assert.isNotNull(token);
    assert.isOk(!token.error);
    assert.strictEqual(token.columns.length, 0x01);

    const column = token.columns[0];
    assert.isNotNull(column);
    assert.strictEqual(column.userType, 0x00);
    assert.strictEqual(column.flags, 0x080B);
    assert.strictEqual(column.colName, 'Name');
    assert.strictEqual(column.dataLength, 0x0241);

    assert.isNotNull(column.type);
    const columnType = column.type;
    assert.strictEqual(columnType.id, 0xA5);
    assert.strictEqual(columnType.type, 'BIGVARBIN');
    assert.strictEqual(columnType.name, 'VarBinary');

    assert.isNotNull(column.collation);
    const columnCollation = column.collation;
    assert.strictEqual(columnCollation.lcid, 0x0409);
    assert.strictEqual(columnCollation.flags, 0x20);
    assert.strictEqual(columnCollation.version, 0x00);
    assert.strictEqual(columnCollation.sortId, 0x00);
    assert.strictEqual(columnCollation.codepage, 'CP1252');

    assert.isNotNull(column.cryptoMetadata);
    const columnCryptoMetadata = column.cryptoMetadata;
    assert.strictEqual(columnCryptoMetadata.ordinal, 0x00);
    assert.strictEqual(columnCryptoMetadata.cipherAlgorithmId, 0x02);
    assert.strictEqual(columnCryptoMetadata.encryptionType, 0x01);
    assert.deepEqual(
      columnCryptoMetadata.normalizationRuleVersion,
      Buffer.from([0x01]),
    );

    assert.isNotNull(columnCryptoMetadata.cekEntry);
    const columnCryptoCekTableEntry = columnCryptoMetadata.cekEntry;
    assert.strictEqual(columnCryptoCekTableEntry.ordinal, 0x01);
    assert.strictEqual(columnCryptoCekTableEntry.databaseId, 0x05);
    assert.strictEqual(columnCryptoCekTableEntry.cekId, 0x31);
    assert.strictEqual(columnCryptoCekTableEntry.cekVersion, 0x01);
    assert.deepEqual(
      columnCryptoCekTableEntry.cekMdVersion,
      Buffer.from([0xF1, 0x08, 0x60, 0x01, 0xE8, 0xAA, 0x00, 0x00]),
    );

    assert.strictEqual(columnCryptoCekTableEntry.columnEncryptionKeyValues.length, 0x01);
    const columnEncryptionKeyValue = columnCryptoCekTableEntry.columnEncryptionKeyValues[0];
    assert.isNotNull(columnEncryptionKeyValue);
    assert.strictEqual(columnEncryptionKeyValue.dbId, 0x05);
    assert.strictEqual(columnEncryptionKeyValue.keyId, 0x31);
    assert.strictEqual(columnEncryptionKeyValue.keyVersion, 0x01);
    assert.deepEqual(
      columnEncryptionKeyValue.mdVersion,
      Buffer.from([0xF1, 0x08, 0x60, 0x01, 0xE8, 0xAA, 0x00, 0x00]),
    );
    assert.strictEqual(columnEncryptionKeyValue.keyPath, 'test');
    assert.strictEqual(columnEncryptionKeyValue.keyStoreName, 'MSSQL_JAVA_KEYSTORE');
    assert.strictEqual(columnEncryptionKeyValue.algorithmName, 'RSA_OAEP');

    assert.isNotNull(columnCryptoMetadata.baseTypeInfo);
    const columnCryptoBaseTypeInfo = columnCryptoMetadata.baseTypeInfo;
    assert.strictEqual(columnCryptoBaseTypeInfo.userType, 0x00);
    assert.strictEqual(columnCryptoBaseTypeInfo.flags, 0x080B);
    assert.strictEqual(columnCryptoBaseTypeInfo.dataLength, 0x0200);

    assert.isNotNull(columnCryptoBaseTypeInfo.type);
    const columnCryptoBaseTypeType = columnCryptoBaseTypeInfo.type;
    assert.strictEqual(columnCryptoBaseTypeType.id, 0xA7);
    assert.strictEqual(columnCryptoBaseTypeType.type, 'BIGVARCHR');
    assert.strictEqual(columnCryptoBaseTypeType.name, 'VarChar');

    assert.isNotNull(columnCryptoBaseTypeInfo.collation);
    const columnCryptoBaseTypeCollation = columnCryptoBaseTypeInfo.collation;
    assert.strictEqual(columnCryptoBaseTypeCollation.lcid, 0x0409);
    assert.strictEqual(columnCryptoBaseTypeCollation.flags, 0x20);
    assert.strictEqual(columnCryptoBaseTypeCollation.version, 0x00);
    assert.strictEqual(columnCryptoBaseTypeCollation.sortId, 0x00);
    assert.strictEqual(columnCryptoBaseTypeCollation.codepage, 'CP1252');

    assert.isTrue((await parser.next()).done);
  });
});
