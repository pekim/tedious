const { assert } = require('chai');

const RpcRequestPayload = require('../../src/rpcrequest-payload');
const { typeByName } = require('../../src/data-type');
const {
  alwaysEncryptedOptions
} = require('./always-encrypted/crypto-util');

const options = {
  useUTC: false,
  tdsVersion: '7_2'
};

const sampleCryptoMetadata = {
  cekEntry: {
    ordinal: 0x01,
    databaseId: 0x00,
    cekId: 0x00,
    cekVersion: 0x00,
    cekMdVersion: 0x00,
    columnEncryptionKeyValues: [{
      encryptedKey: Buffer.from([0x00]),
      dbId: 0x05,
      keyId: 0x31,
      keyVersion: 0x01,
      mdVersion: Buffer.from([
        0xF1, 0x08, 0x60, 0x01, 0xE8, 0xAA, 0x00, 0x00,
      ]),
      keyPath: 'test',
      keyStoreName: 'TEST_KEYSTORE',
      algorithmName: 'RSA_OAEP',
    }],
  },
  cipherAlgorithmId: 0x02,
  encryptionType: 0x01,
  normalizationRuleVersion: Buffer.from([0x01]),
};

describe('RpcRequestPayload', () => {
  it('get data', async function() {
    const payload = new RpcRequestPayload('sp_executesql', [], Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), options);

    const expectedData = Buffer.from([
      // headers
      0x16, 0x00, 0x00, 0x00,
      0x12, 0x00, 0x00, 0x00,
      0x02, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,

      // sql query length
      0x0d, 0x00,

      // sql query
      0x73, 0x00, 0x70, 0x00,
      0x5f, 0x00, 0x65, 0x00,
      0x78, 0x00, 0x65, 0x00,
      0x63, 0x00, 0x75, 0x00,
      0x74, 0x00, 0x65, 0x00,
      0x73, 0x00, 0x71, 0x00,
      0x6c, 0x00,

      // option flags
      0x00, 0x00,
    ]);

    const buffer = [];

    for await (const value of payload) {
      buffer.push(value);
    }

    assert.deepEqual(Buffer.concat(buffer), expectedData);
  });

  it('get data with param', async function() {
    const payload = new RpcRequestPayload('SELECT @param', [
      {
        type: typeByName.Int,
        name: 'param',
        value: 1,
        output: false,
        length: undefined,
        precision: undefined,
        scale: undefined
      }
    ], Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), options);

    const expectedData = Buffer.from([
      // headers
      0x16, 0x00, 0x00, 0x00,
      0x12, 0x00, 0x00, 0x00,
      0x02, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,

      // sql query length
      0x0D, 0x00,

      // sql query
      0x53, 0x00, 0x45, 0x00,
      0x4c, 0x00, 0x45, 0x00,
      0x43, 0x00, 0x54, 0x00,
      0x20, 0x00, 0x40, 0x00,
      0x70, 0x00, 0x61, 0x00,
      0x72, 0x00, 0x61, 0x00,
      0x6d, 0x00,

      // option flags
      0x00, 0x00,

      // parameter name
      0x06, 0x40, 0x00, 0x70, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00,

      // parameter status flags
      0x00,

      // parameter type metadata
      0x26, 0x04,
      // parameter value
      0x04, 0x01, 0x00, 0x00, 0x00
    ]);
    const buffer = [];

    for await (const value of payload) {
      buffer.push(value);
    }

    assert.deepEqual(Buffer.concat(buffer), expectedData);
  });

  it('get data with encrypted param', async function() {
    const payload = new RpcRequestPayload('SELECT @param', [
      {
        type: typeByName.Int,
        name: 'param',
        value: 1,
        output: false,
        length: undefined,
        precision: undefined,
        scale: undefined,

        cryptoMetadata: {
          ...sampleCryptoMetadata,
          baseTypeInfo: { type: typeByName.Int },
        }
      }
    ], Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), alwaysEncryptedOptions);

    const expectedData = Buffer.from([
      // headers
      0x16, 0x00, 0x00, 0x00,
      0x12, 0x00, 0x00, 0x00,
      0x02, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,

      // sql query length
      0x0D, 0x00,

      // sql query
      0x53, 0x00, 0x45, 0x00,
      0x4c, 0x00, 0x45, 0x00,
      0x43, 0x00, 0x54, 0x00,
      0x20, 0x00, 0x40, 0x00,
      0x70, 0x00, 0x61, 0x00,
      0x72, 0x00, 0x61, 0x00,
      0x6d, 0x00,

      // option flags
      0x00, 0x00,

      // parameter name
      0x06, 0x40, 0x00, 0x70, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00,

      // parameter status flags
      0x08,

      // encrypted parameter type metadata
      0xA5, 0x41, 0x00,

      // encrypted parameter value
      0x41, 0x00, 0x01, 0xce, 0xfd, 0x37, 0xdd, 0xa5, 0xd5, 0xd0, 0xcc, 0x3e, 0xaa, 0x8e, 0x1b, 0xc5, 0x8c, 0x0a, 0x33, 0x26, 0x9b, 0x4d, 0x21, 0x30, 0xb2, 0x27, 0xd4, 0x1b, 0x48, 0xe1, 0x6b, 0x1e, 0xac, 0x8d, 0xd4, 0x90, 0xab, 0xa5, 0xc0, 0x7d, 0x90, 0x8f, 0xe6, 0x19, 0x78, 0x9e, 0xdd, 0x28, 0xed, 0x9e, 0xc5, 0x52, 0x3d, 0xa4, 0xa4, 0x5d, 0xff, 0x5f, 0x77, 0x85, 0xea, 0x71, 0x28, 0xa2, 0x9b, 0xc4, 0xc5,

      // base type paramater metadata
      0x26, 0x04,

      // encryption metadata
      sampleCryptoMetadata.cipherAlgorithmId, sampleCryptoMetadata.encryptionType,
      0x05, 0x00, 0x00, 0x00,
      0x31, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,
      ...sampleCryptoMetadata.cekEntry.columnEncryptionKeyValues[0].mdVersion,
      ...sampleCryptoMetadata.normalizationRuleVersion,
    ]);

    const buffer = [];

    for await (const value of payload) {
      buffer.push(value);
    }

    assert.deepEqual(Buffer.concat(buffer), expectedData);
  });

  it('get data with 2 encrypted param', async function() {
    const payload = new RpcRequestPayload('SELECT @param1, @param2', [
      {
        type: typeByName.Int,
        name: 'param1',
        value: 1,
        output: false,
        length: undefined,
        precision: undefined,
        scale: undefined,

        cryptoMetadata: {
          ...sampleCryptoMetadata,
          baseTypeInfo: { type: typeByName.Int },
        }
      },

      {
        type: typeByName.Int,
        name: 'param2',
        value: 2,
        output: false,
        length: undefined,
        precision: undefined,
        scale: undefined,

        cryptoMetadata: {
          ...sampleCryptoMetadata,
          baseTypeInfo: { type: typeByName.Int },
        }
      }
    ], Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), alwaysEncryptedOptions);

    const expectedData = Buffer.from([
      // headers
      0x16, 0x00, 0x00, 0x00,
      0x12, 0x00, 0x00, 0x00,
      0x02, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,

      // sql query length
      0x17, 0x00,

      // sql query
      0x53, 0x00, 0x45, 0x00,
      0x4c, 0x00, 0x45, 0x00,
      0x43, 0x00, 0x54, 0x00,
      0x20, 0x00, 0x40, 0x00,
      0x70, 0x00, 0x61, 0x00,
      0x72, 0x00, 0x61, 0x00,
      0x6d, 0x00, 0x31, 0x00,
      0x2c, 0x00, 0x20, 0x00,
      0x40, 0x00, 0x70, 0x00,
      0x61, 0x00, 0x72, 0x00,
      0x61, 0x00, 0x6d, 0x00,
      0x32, 0x00,

      // option flags
      0x00, 0x00,

      // parameter 1 name
      0x07, 0x40, 0x00, 0x70, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x31, 0x00,

      // parameter 1 status flags
      0x08,

      // encrypted parameter 1 type metadata
      0xA5, 0x41, 0x00,

      // encrypted parameter 1 value
      0x41, 0x00, 0x01, 0xce, 0xfd, 0x37, 0xdd, 0xa5, 0xd5, 0xd0, 0xcc, 0x3e, 0xaa, 0x8e, 0x1b, 0xc5, 0x8c, 0x0a, 0x33, 0x26, 0x9b, 0x4d, 0x21, 0x30, 0xb2, 0x27, 0xd4, 0x1b, 0x48, 0xe1, 0x6b, 0x1e, 0xac, 0x8d, 0xd4, 0x90, 0xab, 0xa5, 0xc0, 0x7d, 0x90, 0x8f, 0xe6, 0x19, 0x78, 0x9e, 0xdd, 0x28, 0xed, 0x9e, 0xc5, 0x52, 0x3d, 0xa4, 0xa4, 0x5d, 0xff, 0x5f, 0x77, 0x85, 0xea, 0x71, 0x28, 0xa2, 0x9b, 0xc4, 0xc5,

      // base type parameter 1 metadata
      0x26, 0x04,

      // parameter 1 encryption metadata
      sampleCryptoMetadata.cipherAlgorithmId, sampleCryptoMetadata.encryptionType,
      0x05, 0x00, 0x00, 0x00,
      0x31, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,
      ...sampleCryptoMetadata.cekEntry.columnEncryptionKeyValues[0].mdVersion,
      ...sampleCryptoMetadata.normalizationRuleVersion,

      // parameter 2 name
      0x07, 0x40, 0x00, 0x70, 0x00, 0x61, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x32, 0x00,

      // parameter 2 status flags
      0x08,

      // encrypted parameter 2 type metadata
      0xA5, 0x41, 0x00,

      // encrypted parameter 2 value
      ...Buffer.from('41000150087ab978e0443ad69a05a405aaaef57e9e23507ead6c4608947fa7c1b3d333af760ae3df6d2b2a54ca57f181ae43b28eddc56e88934dc898c4e197e86993b6', 'hex'),

      // base type parameter 2 metadata
      0x26, 0x04,

      // parameter 2 encryption metadata
      sampleCryptoMetadata.cipherAlgorithmId, sampleCryptoMetadata.encryptionType,
      0x05, 0x00, 0x00, 0x00,
      0x31, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00,
      ...sampleCryptoMetadata.cekEntry.columnEncryptionKeyValues[0].mdVersion,
      ...sampleCryptoMetadata.normalizationRuleVersion,
    ]);

    const buffer = [];

    for await (const value of payload) {
      buffer.push(value);
    }

    assert.deepEqual(Buffer.concat(buffer), expectedData);
  });
});
